// Name: Text
// ID: strings
// Description: Manipulate characters and text.
// By: CST1229 <https://scratch.mit.edu/users/CST1229/>
// By: BludIsAnLemon <https://scratch.mit.edu/users/BludIsAnLemon/>
// By: Man-o-Valor <https://scratch.mit.edu/users/man-o-valor/>
// License: MIT AND MPL-2.0

/* generated l10n code */Scratch.translate.setup({"es":{"_Text":"Texto"},"fi":{"_Exactly Title Case":"Alkukirjaimet Tarkasti Isolla","_MiXeD CaSe":"IsOt jA PiEnEt kIrJaImEt sEkAiSiN","_RAndoMCaSe":"SATuNnaiNEn KirJaInKoKO","_Sentence case":"Virkkeen alkukirjain isolla","_Text":"Teksti","_Title Case":"Alkukirjaimet Isolla","_UPPERCASE":"ISOT KIRJAIMET","_[STRING] [POSITION]s with [SUBSTRING]?":"[POSITION] [STRING] merkkijonolla [SUBSTRING]?","_[STRING] matches regex /[REGEX]/[FLAGS]?":"vastaako [STRING] säännöllistä lauseketta /[REGEX]/[FLAGS]?","_apple":"omena","_both sides":"molemmilta puolilta","_camelCase":"karavaaniTyyli","_convert [STRING] to [TEXTCASE]":"muunna [STRING] muotoon [TEXTCASE]","_count [SUBSTRING] in [STRING]":"merkkien [SUBSTRING] määrä merkkijonossa [STRING]","_count regex /[REGEX]/[FLAGS] in [STRING]":"laske säännöllinen lauseke /[REGEX]/[FLAGS] merkkijonossa [STRING]","_end":"päättyykö","_index of [SUBSTRING] in [STRING]":"merkkijonon [SUBSTRING] järjestysnumero merkkijonossa [STRING]","_is [OPERAND1] identical to [OPERAND2]?":"onko [OPERAND1] täysin sama kuin [OPERAND2]?","_is [STRING] [TEXTCASE]?":"onko [STRING] muodossa [TEXTCASE]?","_item [ITEM] of [STRING] matched by regex /[REGEX]/[FLAGS]":"merkkijonon [STRING] [ITEM]. kohde, joka vastaa säännöllistä lauseketta /[REGEX]/[FLAGS]","_item [ITEM] of [STRING] split by [SPLIT]":"[ITEM]. kohde merkkijonosta [STRING] jaettuna merkillä [SPLIT]","_letters [LETTER1] to [LETTER2] of [STRING]":"merkkijonon [STRING] merkit [LETTER1] – [LETTER2]","_lowercase":"pienet kirjaimet","_repeat [STRING] [REPEAT] times":"toista [STRING] [REPEAT] kertaa","_replace [SUBSTRING] in [STRING] with [REPLACE]":"korvaa [SUBSTRING] merkkijonossa [STRING] merkkijonolla [REPLACE]","_replace regex /[REGEX]/[FLAGS] in [STRING] with [REPLACE]":"korvaa säännöllinen lauseke /[REGEX]/[FLAGS] merkkijonossa [STRING] lausekkeella [REPLACE]","_reverse text [STRING]":"teksti [STRING] käänteisenä","_start":"alkaako","_the end":"lopusta","_the start":"alusta","_trim whitespace [STRING] from [METHOD]":"poista turhat sanavälit merkkijonon [STRING] [METHOD]","_unicode [NUM] as letter":"Unicode-koodi [NUM] merkkijonona","_unicode of [STRING]":"merkkijonon [STRING] Unicode-koodi"},"he":{"_Text":"טקסט"},"hu":{"_Text":"Szöveg"},"it":{"_RAndoMCaSe":"CaSUaLe","_Sentence case":"Stile maiuscole frase","_Text":"Testo","_[STRING] [POSITION]s with [SUBSTRING]?":"[STRING][POSITION] con [SUBSTRING]","_apple":"mela","_both sides":"entrambi i lati","_camelCase":"maiuscoleInterne","_end":"finisce","_reverse text [STRING]":"inverti testo [STRING]","_start":"inizia","_the end":"la fine","_the start":"l'inizio","_trim whitespace [STRING] from [METHOD]":"Rimuovi spazi bianchi di [STRING] da [METHOD]"},"ja":{"_Exactly Title Case":"正確なタイトルケース","_MiXeD CaSe":"ミックスケース","_Text":"テキスト","_Title Case":"タイトルケース","_UPPERCASE":"大文字","_apple":"りんご","_convert [STRING] to [TEXTCASE]":"[STRING]を[TEXTCASE]に変換する","_count [SUBSTRING] in [STRING]":"[STRING]に[SUBSTRING]が出てきた回数","_end":"End","_index of [SUBSTRING] in [STRING]":"[STRING]の[SUBSTRING]の場所","_is [OPERAND1] identical to [OPERAND2]?":"[OPERAND1]と[OPERAND2]が同一","_is [STRING] [TEXTCASE]?":"[STRING]が[TEXTCASE]","_item [ITEM] of [STRING] split by [SPLIT]":"[STRING]を[SPLIT]で区切ったときの[ITEM]番目","_letters [LETTER1] to [LETTER2] of [STRING]":"[STRING]の[LETTER1]から[LETTER2]文字目","_lowercase":"小文字","_repeat [STRING] [REPEAT] times":"[STRING]を[REPEAT]回繰り返す","_replace [SUBSTRING] in [STRING] with [REPLACE]":"[STRING]の[SUBSTRING]を[REPLACE]で置き換える","_unicode [NUM] as letter":"Unicode[NUM]の文字","_unicode of [STRING]":"[STRING]のUnicode"},"ko":{"_Exactly Title Case":"정확한 제목 표기법 (Abc Abc)","_MiXeD CaSe":"섞인 표기법 (AbC AbCd)","_Text":"텍스트","_Title Case":"제목 표기법 (Abc Abc)","_UPPERCASE":"대문자 표기법 (ABC)","_[STRING] matches regex /[REGEX]/[FLAGS]?":"[STRING]이(가) 정규표현식 /[REGEX]/[FLAGS] 에 일치하는가?","_convert [STRING] to [TEXTCASE]":"[STRING]을(를) [TEXTCASE](으)로 변환하기","_count [SUBSTRING] in [STRING]":"[STRING]에서 [SUBSTRING]의 개수","_count regex /[REGEX]/[FLAGS] in [STRING]":"[STRING]에서 정규표현식 /[REGEX]/[FLAGS] 의 결과 개수","_index of [SUBSTRING] in [STRING]":"[STRING]에서 [SUBSTRING]의 번째","_is [OPERAND1] identical to [OPERAND2]?":"[OPERAND1]이(가) [OPERAND2]와(과) 정확히 같지 않은가?","_is [STRING] [TEXTCASE]?":"[STRING]이(가) [TEXTCASE]인가?","_item [ITEM] of [STRING] matched by regex /[REGEX]/[FLAGS]":"[STRING]에서 정규표현식 /[REGEX]/[FLAGS] 의 [ITEM]번째 결과","_item [ITEM] of [STRING] split by [SPLIT]":"[STRING]을(를) [SPLIT](으)로 나눈 것의 [ITEM]번째","_letters [LETTER1] to [LETTER2] of [STRING]":"[STRING]의 [START]부터 [END]까지의 글자","_lowercase":"소문자 표기법 (abc)","_repeat [STRING] [REPEAT] times":"[STRING] 문자열 [REPEAT]번 반복","_replace [SUBSTRING] in [STRING] with [REPLACE]":"[STRING]의 [SUBSTRING]을(를) [REPLACE](으)로 바꾸기","_replace regex /[REGEX]/[FLAGS] in [STRING] with [REPLACE]":"정규표현식 /[REGEX]/[FLAGS] (으)로 [STRING]을(를) [REPLACE](으)로 바꾸기","_unicode [NUM] as letter":"유니코드 문자 [NUM]","_unicode of [STRING]":"[STRING]의 유니코드"},"nb":{"_Text":"Tekst","_end":"slutt"},"nl":{"_Exactly Title Case":"Alleen Beginhoofdletters","_MiXeD CaSe":"DoOr eLkAaR","_Text":"Tekst","_Title Case":"Alles Met Beginhoofdletter","_UPPERCASE":"HOOFDLETTERS","_[STRING] matches regex /[REGEX]/[FLAGS]?":"[STRING] komt overeen met regex /[REGEX]/[FLAGS]?","_apple":"appel","_convert [STRING] to [TEXTCASE]":"zet [STRING] om naar [TEXTCASE]","_count [SUBSTRING] in [STRING]":"aantal [SUBSTRING] in [STRING]","_count regex /[REGEX]/[FLAGS] in [STRING]":"aantal overeenkomsten van regex /[REGEX]/[FLAGS] met [STRING]","_index of [SUBSTRING] in [STRING]":"positie van [SUBSTRING] in [STRING]","_is [OPERAND1] identical to [OPERAND2]?":"[OPERAND1] identiek aan [OPERAND2]?","_item [ITEM] of [STRING] matched by regex /[REGEX]/[FLAGS]":"item [ITEM] van [STRING] waarmee regex /[REGEX]/[FLAGS] overeenkomt","_item [ITEM] of [STRING] split by [SPLIT]":"item [ITEM] van [STRING] gesplitst door [SPLIT]","_letters [LETTER1] to [LETTER2] of [STRING]":"letters [LETTER1] t/m [LETTER2] van [STRING]","_lowercase":"kleine letters","_repeat [STRING] [REPEAT] times":"herhaal [STRING] [REPEAT] keer","_replace [SUBSTRING] in [STRING] with [REPLACE]":"vervang [SUBSTRING] in [STRING] door [REPLACE]","_replace regex /[REGEX]/[FLAGS] in [STRING] with [REPLACE]":"vervang regex /[REGEX]/[FLAGS] in [STRING] door [REPLACE]","_unicode [NUM] as letter":"unicode [NUM] als letter","_unicode of [STRING]":"unicode van [STRING]"},"pl":{"_Text":"Tekst"},"pt-br":{"_Text":"Texto"},"ru":{"_Exactly Title Case":"Настоящий Тайтл Кейс","_MiXeD CaSe":"СмЕшАнНыЙ КеЙс","_RAndoMCaSe":"СЛуЧайнЫЙРеГисТР","_Sentence case":"Смысловой регистр","_Text":"Текст","_Title Case":"Тайтл Кейс","_UPPERCASE":"ВЕРХНИЙ РЕГИСТР","_[STRING] [POSITION]s with [SUBSTRING]?":"[STRING] [POSITION] с [SUBSTRING]?","_[STRING] matches regex /[REGEX]/[FLAGS]?":"[STRING] совпадает с regex'ом /[REGEX]/[FLAGS]?","_apple":"яблоко","_both sides":"обе стороны","_camelCase":"Регистр верблюда","_convert [STRING] to [TEXTCASE]":"сконвертировать строку [STRING] в [TEXTCASE]","_count [SUBSTRING] in [STRING]":"количество [SUBSTRING] в [STRING]","_count regex /[REGEX]/[FLAGS] in [STRING]":"посчитать regex /[REGEX]/[FLAGS] в [STRING]","_end":"конец","_index of [SUBSTRING] in [STRING]":"индекс [SUBSTRING] в [STRING]","_is [OPERAND1] identical to [OPERAND2]?":"[OPERAND1] идентичный с [OPERAND2]?","_is [STRING] [TEXTCASE]?":"строка [STRING] это [TEXTCASE]?","_item [ITEM] of [STRING] matched by regex /[REGEX]/[FLAGS]":"предмет [ITEM] строки [STRING] совпадающий regex'ом /[REGEX]/[FLAGS]","_item [ITEM] of [STRING] split by [SPLIT]":"предмет [ITEM] строки [STRING] распределённый [SPLIT]","_letters [LETTER1] to [LETTER2] of [STRING]":"буквы с [LETTER1] до [LETTER2] строки [STRING]","_lowercase":"нижний регистр","_repeat [STRING] [REPEAT] times":"повторить [STRING] [REPEAT] раз","_replace [SUBSTRING] in [STRING] with [REPLACE]":"заменить [SUBSTRING] в [STRING] на [REPLACE]","_replace regex /[REGEX]/[FLAGS] in [STRING] with [REPLACE]":"заменить regex /[REGEX]/[FLAGS] в [STRING] на [REPLACE]","_reverse text [STRING]":"перевернуть текст [STRING]","_start":"начало","_the end":"конца","_the start":"начала","_trim whitespace [STRING] from [METHOD]":"обрезать пробелы [STRING] из [METHOD]","_unicode [NUM] as letter":"юникод [NUM] как букву","_unicode of [STRING]":"юникод [STRING]"},"sl":{"_Text":"Besedilo"},"tr":{"_Text":"Metin"},"uk":{"_Exactly Title Case":"Точно Заголовком","_MiXeD CaSe":"МіШаНиМи","_RAndoMCaSe":"ВИпадКоВИМи","_Sentence case":"Речення","_Text":"Текст","_Title Case":"Заголовком","_UPPERCASE":"ВЕЛИКИМИ БУКВАМИ","_[STRING] [POSITION]s with [SUBSTRING]?":"[STRING] [POSITION] з [SUBSTRING]?","_both sides":"обох сторін","_convert [STRING] to [TEXTCASE]":"зробити [STRING] [TEXTCASE]","_count [SUBSTRING] in [STRING]":"кількість [SUBSTRING] у [STRING]","_end":"закінчується","_index of [SUBSTRING] in [STRING]":"номер [SUBSTRING] у [STRING]","_is [OPERAND1] identical to [OPERAND2]?":"[OPERAND1] ідентична до [OPERAND2]?","_is [STRING] [TEXTCASE]?":"[STRING] є [TEXTCASE]?","_item [ITEM] of [STRING] split by [SPLIT]":"елемент [ITEM] у [STRING] розділеного через [SPLIT]","_letters [LETTER1] to [LETTER2] of [STRING]":"букви з [LETTER1] по [LETTER2] у [STRING]","_lowercase":"малими буквами","_repeat [STRING] [REPEAT] times":"повторити [STRING] [REPEAT] рази","_replace [SUBSTRING] in [STRING] with [REPLACE]":"замінити [SUBSTRING] у [STRING] на [REPLACE]","_reverse text [STRING]":"розвернути [STRING]","_start":"починається","_the end":"початку","_the start":"кінця","_trim whitespace [STRING] from [METHOD]":"очистити пробіли у [STRING] з [METHOD]","_unicode [NUM] as letter":"символ юнікоду [NUM] ","_unicode of [STRING]":"юнікод [STRING]"},"zh-cn":{"_Exactly Title Case":"精确标题","_MiXeD CaSe":"混合大小写","_RAndoMCaSe":"随机大小写","_Sentence case":"句首大写","_Text":"文本","_Title Case":"标题","_UPPERCASE":"大写","_[STRING] [POSITION]s with [SUBSTRING]?":"[STRING]以[SUBSTRING][POSITION]？","_[STRING] matches regex /[REGEX]/[FLAGS]?":"[STRING] 满足正则表达式 /[REGEX]/[FLAGS]？","_apple":"苹果","_both sides":"两边","_camelCase":"驼峰式命名","_convert [STRING] to [TEXTCASE]":"转换[STRING]为[TEXTCASE]","_count [SUBSTRING] in [STRING]":"[STRING]中[SUBSTRING]的数量","_count regex /[REGEX]/[FLAGS] in [STRING]":"使用正则表达式 /[REGEX]/[FLAGS] 在 [STRING] 匹配的数量","_end":"End","_index of [SUBSTRING] in [STRING]":"[STRING]中[SUBSTRING]的位置","_is [OPERAND1] identical to [OPERAND2]?":"[OPERAND1]===[OPERAND2]","_is [STRING] [TEXTCASE]?":"[STRING]是[TEXTCASE]？","_item [ITEM] of [STRING] matched by regex /[REGEX]/[FLAGS]":"使用正则表达式 /[REGEX]/[FLAGS]匹配[STRING]的第[ITEM]个内容","_item [ITEM] of [STRING] split by [SPLIT]":"以[SPLIT]分割[STRING]后的第[ITEM]项","_letters [LETTER1] to [LETTER2] of [STRING]":"[STRING]的第[LETTER1]到第[LETTER2]位","_lowercase":"小写","_repeat [STRING] [REPEAT] times":"重复[REPEAT]个[STRING]","_replace [SUBSTRING] in [STRING] with [REPLACE]":"替换[STRING]中的[SUBSTRING]为[REPLACE]","_replace regex /[REGEX]/[FLAGS] in [STRING] with [REPLACE]":"使用正则表达式 /[REGEX]/[FLAGS] 在 [STRING]中替换为  [REPLACE]","_reverse text [STRING]":"反转文本[STRING]","_start":"开头","_the end":"末尾","_the start":"开头","_trim whitespace [STRING] from [METHOD]":"去除[STRING]中[METHOD]的空格","_unicode [NUM] as letter":"unicode[NUM]对应的字符","_unicode of [STRING]":"[STRING]的unicode"}});/* end generated l10n code */(function (Scratch) {
  "use strict";

  const CaseParam = {
    LOWERCASE: "lowercase",
    UPPERCASE: "uppercase",
    MIXEDCASE: "mixedcase",
    TITLECASE: "titlecase",
    EXACTTITLECASE: "exacttitlecase",
    RANDOMCASE: "randomcase",
    SENTENCECASE: "sentencecase",
    CAMELCASE: "camelcase",
  };

  let splitCache;
  let matchCache;

  class StringsExt {
    constructor() {}

    _initCaseMenu() {
      return [
        {
          text: Scratch.translate({
            default: "lowercase",
            description: "If your language has lowercase, style it accordingly",
          }),
          value: CaseParam.LOWERCASE,
        },
        {
          text: Scratch.translate({
            default: "UPPERCASE",
            description: "If your language has uppercase, style it accordingly",
          }),
          value: CaseParam.UPPERCASE,
        },
        {
          text: Scratch.translate({
            default: "Sentence case",
            description:
              "Starts words after ., !, and ? with captialized letters",
          }),
          value: CaseParam.SENTENCECASE,
        },
        {
          text: Scratch.translate({
            default: "Title Case",
            description:
              "If your language has Title Case, style it accordingly. 'Abc' is title case and exactly title case but 'ABC' is only title case.",
          }),
          value: CaseParam.TITLECASE,
        },
        {
          text: Scratch.translate({
            default: "Exactly Title Case",
            description:
              "If your language has Title Case, style it accordingly. 'Abc' is title case and exactly title case but 'ABC' is only title case.",
          }),
          value: CaseParam.EXACTTITLECASE,
        },
        {
          text: Scratch.translate({
            default: "MiXeD CaSe",
            description:
              "If your language has mixed case, style it accordingly",
          }),
          value: CaseParam.MIXEDCASE,
        },
        {
          text: Scratch.translate({
            default: "RAndoMCaSe",
            description:
              "If your language has randomcase, style it accordingly",
          }),
          value: CaseParam.RANDOMCASE,
        },
        {
          text: Scratch.translate({
            default: "camelCase",
            description:
              "Removes all spaces and capitalizes all words after the first",
          }),
          value: CaseParam.CAMELCASE,
        },
      ];
    }

    getInfo() {
      return {
        // id "text" would conflict with Scratch Lab's Animated Text (lab/text.js)
        id: "strings",
        name: Scratch.translate("Text"),
        blocks: [
          {
            opcode: "letters_of",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate(
              "letters [LETTER1] to [LETTER2] of [STRING]"
            ),
            arguments: {
              LETTER1: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 2,
              },
              LETTER2: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 4,
              },
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple",
              },
            },
          },
          {
            opcode: "split",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("item [ITEM] of [STRING] split by [SPLIT]"),
            arguments: {
              ITEM: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 3,
              },
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple",
              },
              SPLIT: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "p",
              },
            },
          },
          {
            opcode: "count",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate({
              default: "count [SUBSTRING] in [STRING]",
              description:
                "Counts how many time [SUBSTRING] appears in [STRING]",
            }),
            arguments: {
              SUBSTRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "p",
              },
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple",
              },
            },
          },
          {
            opcode: "indexof",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate({
              default: "index of [SUBSTRING] in [STRING]",
              description: "Reports where [SUBSTRING] appears in [STRING]",
            }),
            arguments: {
              SUBSTRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "p",
              },
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple",
              },
            },
          },

          "---",

          {
            opcode: "replace",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate(
              "replace [SUBSTRING] in [STRING] with [REPLACE]"
            ),
            arguments: {
              SUBSTRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "world",
              },
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello world!",
              },
              REPLACE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "fellow Scratchers",
              },
            },
          },
          {
            opcode: "repeat",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("repeat [STRING] [REPEAT] times"),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple ",
              },
              REPEAT: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 3,
              },
            },
          },

          "---",

          {
            opcode: "unicodeof",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("unicode of [STRING]"),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "A",
              },
            },
          },
          {
            opcode: "unicodefrom",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("unicode [NUM] as letter"),
            arguments: {
              NUM: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 65,
              },
            },
          },

          "---",
          {
            opcode: "replaceRegex",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate(
              "replace regex /[REGEX]/[FLAGS] in [STRING] with [REPLACE]"
            ),
            arguments: {
              REGEX: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: ".",
              },
              FLAGS: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "g",
              },
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello world!",
              },
              REPLACE: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "$&$&",
              },
            },
          },
          {
            opcode: "matchRegex",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate({
              default:
                "item [ITEM] of [STRING] matched by regex /[REGEX]/[FLAGS]",
              description:
                "/[REGEX]/ is supposed to match the syntax that some actual programming languages used for regular expressions.",
            }),
            arguments: {
              ITEM: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: 1,
              },
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello world!",
              },
              REGEX: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "(.) (.{2})",
              },
              FLAGS: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "g",
              },
            },
          },
          {
            opcode: "countRegex",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate({
              default: "count regex /[REGEX]/[FLAGS] in [STRING]",
              description:
                "/[REGEX]/ is supposed to match the syntax that some actual programming languages used for regular expressions.",
            }),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello world!",
              },
              REGEX: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "[AEIOU]",
              },
              FLAGS: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "i",
              },
            },
          },
          {
            opcode: "testRegex",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate({
              default: "[STRING] matches regex /[REGEX]/[FLAGS]?",
              description:
                "/[REGEX]/ is supposed to match the syntax that some actual programming languages used for regular expressions.",
            }),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "Hello world!",
              },
              REGEX: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "hello",
              },
              FLAGS: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "i",
              },
            },
          },

          "---",

          {
            opcode: "identical",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("is [OPERAND1] identical to [OPERAND2]?"),
            arguments: {
              OPERAND1: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "A",
              },
              OPERAND2: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "a",
              },
            },
          },

          "---",

          {
            opcode: "isCase",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate({
              default: "is [STRING] [TEXTCASE]?",
              description: "Example block context: <is [hello] [lowercase] ?>",
            }),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple",
              },
              TEXTCASE: {
                type: Scratch.ArgumentType.STRING,
                menu: "textCase",
                defaultValue: CaseParam.LOWERCASE,
              },
            },
          },
          {
            opcode: "toCase",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate({
              default: "convert [STRING] to [TEXTCASE]",
              description:
                "Example block context: (convert [HELLO] to [lowercase])",
            }),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "apple",
              },
              TEXTCASE: {
                type: Scratch.ArgumentType.STRING,
                menu: "textCase",
                defaultValue: CaseParam.UPPERCASE,
              },
            },
          },

          "---",
          {
            opcode: "posWith",
            blockType: Scratch.BlockType.BOOLEAN,
            text: Scratch.translate("[STRING] [POSITION]s with [SUBSTRING]?"),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "turbowarp",
              },
              POSITION: {
                type: Scratch.ArgumentType.STRING,
                menu: "positions",
              },
              SUBSTRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: "turbo",
              },
            },
          },

          "---",

          {
            opcode: "reverse",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("reverse text [STRING]"),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: Scratch.translate("apple"),
              },
            },
          },

          "---",

          {
            opcode: "trim",
            blockType: Scratch.BlockType.REPORTER,
            text: Scratch.translate("trim whitespace [STRING] from [METHOD]"),
            arguments: {
              STRING: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: `    ${Scratch.translate("apple")}    `,
              },
              METHOD: {
                type: Scratch.ArgumentType.STRING,
                menu: "trimMethod",
              },
            },
          },
        ],
        menus: {
          textCase: {
            acceptReporters: true,
            items: this._initCaseMenu(),
          },
          positions: {
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("start"),
                value: "starts",
              },
              {
                text: Scratch.translate("end"),
                value: "ends",
              },
            ],
          },
          trimMethod: {
            acceptReporters: true,
            items: [
              {
                text: Scratch.translate("both sides"),
                value: "both",
              },
              {
                text: Scratch.translate("the end"),
                value: "end",
              },
              {
                text: Scratch.translate("the start"),
                value: "start",
              },
            ],
          },
        },
      };
    }

    identical(args, util) {
      // Purposefully no casting, because
      // types ARE differentiated in this block
      return args.OPERAND1 === args.OPERAND2;
    }

    unicodeof(args, util) {
      const chars = Array.from(Scratch.Cast.toString(args.STRING));
      return chars.map((char) => char.charCodeAt(0)).join(" ");
    }

    unicodefrom(args, util) {
      return String.fromCharCode(Number(args.NUM) || 0);
    }

    letters_of(args, util) {
      const string = Scratch.Cast.toString(args.STRING);
      const letter1 = Scratch.Cast.toNumber(args.LETTER1);
      const letter2 = Scratch.Cast.toNumber(args.LETTER2);
      return string.substring(letter1 - 1, letter2);
    }

    _caseInsensitiveRegex(str) {
      return new RegExp(str.replaceAll(/[^a-zA-Z0-9]/g, "\\$&"), "gi");
    }

    split(args, util) {
      const string = Scratch.Cast.toString(args.STRING);
      const split = Scratch.Cast.toString(args.SPLIT);
      const item = Scratch.Cast.toNumber(args.ITEM);

      // Cache the last split
      if (
        !(
          splitCache &&
          splitCache.string === string &&
          splitCache.split === split
        )
      ) {
        const regex = this._caseInsensitiveRegex(split);

        splitCache = {
          string,
          split,
          arr: string.split(regex),
        };
      }
      return splitCache.arr[item - 1] || "";
    }

    count(args, util) {
      // Fill cache
      this.split(
        {
          SPLIT: args.SUBSTRING,
          STRING: args.STRING,
          ITEM: 0,
        },
        util
      );
      return splitCache.arr.length - 1 || 0;
    }

    replace(args, util) {
      const string = Scratch.Cast.toString(args.STRING);
      const substring = Scratch.Cast.toString(args.SUBSTRING);
      const replace = Scratch.Cast.toString(args.REPLACE);

      const regex = this._caseInsensitiveRegex(substring);

      return string.replace(regex, replace);
    }

    indexof(args, util) {
      // .toLowerCase() for case insensitivity
      const string = Scratch.Cast.toString(args.STRING).toLowerCase();
      const substring = Scratch.Cast.toString(args.SUBSTRING).toLowerCase();

      // Since both arguments are casted to strings beforehand,
      // we don't have to worry about type differences
      // like in the item number of in list block
      const found = string.indexOf(substring);

      // indexOf returns -1 when no matches are found, we can just +1
      return found + 1;
    }

    repeat(args, util) {
      const string = Scratch.Cast.toString(args.STRING);
      const repeat = Scratch.Cast.toNumber(args.REPEAT);
      return string.repeat(repeat);
    }

    replaceRegex(args, util) {
      try {
        const string = Scratch.Cast.toString(args.STRING);
        const replacer = Scratch.Cast.toString(args.REPLACE);
        const regex = Scratch.Cast.toString(args.REGEX);
        const flags = Scratch.Cast.toString(args.FLAGS);

        return string.replace(new RegExp(regex, flags), replacer);
      } catch (e) {
        console.error(e);
        return "";
      }
    }

    matchRegex(args, util) {
      try {
        const string = Scratch.Cast.toString(args.STRING);
        const uncleanRegex = Scratch.Cast.toString(args.REGEX);
        const flags = Scratch.Cast.toString(args.FLAGS);
        const item = Scratch.Cast.toNumber(args.ITEM);

        // Cache the last matched string
        if (
          !(
            matchCache &&
            matchCache.string === string &&
            matchCache.regex === uncleanRegex &&
            matchCache.flags === flags
          )
        ) {
          const newFlags = flags.includes("g") ? flags : flags + "g";
          const regex = new RegExp(uncleanRegex, newFlags);

          matchCache = {
            string,
            regex: uncleanRegex,
            flags,
            arr: string.match(regex) || [],
          };
        }
        return matchCache.arr[item - 1] || "";
      } catch (e) {
        console.error(e);
        return "";
      }
    }

    countRegex(args, util) {
      // Fill cache
      // (ITEM is casted into 0,
      // but we don't care about the return value)
      this.matchRegex(args, util);
      return matchCache.arr.length || 0;
    }

    testRegex(args, util) {
      try {
        const string = Scratch.Cast.toString(args.STRING);
        const regex = Scratch.Cast.toString(args.REGEX);
        const flags = Scratch.Cast.toString(args.FLAGS);

        return new RegExp(regex, flags).test(string);
      } catch (e) {
        console.error(e);
        return false;
      }
    }

    isCase(args, util) {
      const string = Scratch.Cast.toString(args.STRING);
      const textCase = Scratch.Cast.toString(args.TEXTCASE);
      switch (textCase) {
        case CaseParam.LOWERCASE:
          return string.toLowerCase() === string;
        case CaseParam.UPPERCASE:
          return string.toUpperCase() === string;
        case CaseParam.MIXEDCASE:
          return !(
            string.toUpperCase() === string || string.toLowerCase() === string
          );
        case CaseParam.TITLECASE:
          return string.split(/\b/g).every((word) => {
            if (!word) return true;
            const titleCased = word[0].toUpperCase() + word.substring(1);
            return word === titleCased;
          });
        case CaseParam.EXACTTITLECASE:
          return string.split(/\b/g).every((word) => {
            if (!word) return true;
            const titleCased =
              word[0].toUpperCase() + word.substring(1).toLowerCase();
            return word === titleCased;
          });
        case CaseParam.CAMELCASE:
          return /^[^A-Z\s][^\s]*$/.test(string);
        case CaseParam.RANDOMCASE:
          return true;
        case CaseParam.SENTENCECASE:
          return /^[A-Z][^?.!]*(?:[?.!]\s+[A-Z][^?.!]*)*$/.test(string);
        default:
          return false;
      }
    }

    toCase(args, util) {
      const string = Scratch.Cast.toString(args.STRING);
      const textCase = Scratch.Cast.toString(args.TEXTCASE);
      let workingText = "";
      let sentenceCapitalFlag = false;
      switch (textCase) {
        case CaseParam.LOWERCASE:
          return string.toLowerCase();
        case CaseParam.UPPERCASE:
          return string.toUpperCase();
        case CaseParam.MIXEDCASE:
          return Array.from(string)
            .map((char, index) =>
              index % 2 === 0 ? char.toUpperCase() : char.toLowerCase()
            )
            .join("");
        case CaseParam.TITLECASE:
          return string
            .split(/\b/g)
            .map((word) => {
              if (!word) return "";
              return word[0].toUpperCase() + word.substring(1);
            })
            .join("");
        case CaseParam.EXACTTITLECASE:
          return string
            .split(/\b/g)
            .map((word) => {
              if (!word) return "";
              return word[0].toUpperCase() + word.substring(1).toLowerCase();
            })
            .join("");
        case CaseParam.SENTENCECASE:
          for (let i = 0; i < string.length; i++) {
            if (
              /^\s*$/.test(string[i - 1] ?? " ") &&
              !sentenceCapitalFlag &&
              string[i].toUpperCase() != string[i].toLowerCase()
            ) {
              workingText += string[i].toUpperCase();
              sentenceCapitalFlag = true;
            } else {
              if (string[i] == "." || string[i] == "!" || string[i] == "?") {
                sentenceCapitalFlag = false;
              }
              workingText += string[i].toLowerCase();
            }
          }
          return workingText;
        case CaseParam.RANDOMCASE:
          for (let i = 0; i < string.length; i++) {
            if (Math.random() > 0.5) {
              workingText += string[i].toUpperCase();
            } else {
              workingText += string[i].toLowerCase();
            }
          }
          return workingText;
        case CaseParam.CAMELCASE:
          for (let i = 0; i < string.length; i++) {
            if (/^\s*$/.test(string[i - 1] ?? "x")) {
              workingText += string[i].toUpperCase();
            } else {
              workingText += string[i].toLowerCase();
            }
          }
          return workingText.replace(/\s/g, "");
        default:
          return string;
      }
    }
    posWith(args) {
      const STRING = Scratch.Cast.toString(args.STRING);
      const SUBSTRING = Scratch.Cast.toString(args.SUBSTRING);
      if (Scratch.Cast.toString(args.POSITION) === "starts") {
        return STRING.startsWith(SUBSTRING);
      }
      return STRING.endsWith(SUBSTRING);
    }
    reverse(args) {
      return Array.from(Scratch.Cast.toString(args.STRING)).reverse().join("");
    }
    trim(args) {
      const STRING = Scratch.Cast.toString(args.STRING);
      switch (Scratch.Cast.toString(args.METHOD)) {
        case "start":
          return STRING.trimStart();
        case "end":
          return STRING.trimEnd();
        case "both":
        default:
          return STRING.trim();
      }
    }
  }

  Scratch.extensions.register(new StringsExt());
})(Scratch);
